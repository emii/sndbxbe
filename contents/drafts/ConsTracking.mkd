Date: 2013-06-07
Title: Edge-aware conservation tracking
Summary: Adding edge-aware weight function to the tracker
Category: projects
Tags: programming, research, hci, ilastik

Ilastik incorporates the functionallity of the tracker with the library pgmlink, wich is available as a dll, or shared object in linux (.so). This library (libpgmlink.so) can be then imported by calling import pgmlink in any python script. The library is build with the help of the boost python library, which wraps Cpp functions into a namespace (*not sure if this is correct*).

## Interface with Ilastik

The tracker is implemented in Ilastik into an `OpConservationTracking` class which inherits from `OpTrackingBase` likewise from Operator class from lazyflow. First the `OpTrackingBase` method `_generate_traxelstore()` instanciates the class from pgmlink `pgmlink.TraxelStore` (wrapper found on `python/pytraxels.cpp`) meanwhile it is filled with *traxels* (objects and features). Second a pgmlink `pgmlink.ConsTracking` class is instanciated with the tracking parameters as arguments, next it is called with the `pgmlink.TraxelStore` instance as argument.

	::python
	def track(self,...):
	    ts, ~, ~ = self._generate_traxelstore(...)
	    tracker = pgmlink.ConsTracking(...)
	    self.events = tracker(ts)

## Implementation of the boost python wrapper

Ilastik instanciates the class and gives the corresponding arguments for the constructor `pgmlink.ConsTracking(...)` which is the prototype definition for boost/python is in `python/pytrack.cpp`, the function can be then called (`.def("__call__", &ConsTracking::operator())`) by operator overflow.

from file:`python/pytrack.cpp` : 

	::cpp
	    class_<ConsTracking>("ConsTracking", #Class name
                        init<int, ...>( #argument types
			args("max_number_objects", ...) #argument names
					)
				)		
	  .def("__call__", &ConsTracking::operator()) #operator overflow for function calling, links the __call__ in python to the () operator
	  .def("detections", &ConsTracking::detections) #?
	;

## Prototype definition `class ConsTracking` 

from file: `include/tracking.h` :

	::cpp
	  class ConsTracking {
    public:
	  ConsTracking( //Constructor definition for class ConsTracking 
		  int max_number_objects=3, ... //argument definitons 
  	      )
        : max_number_objects_(max_number_objects), ... //member initialization by inheritance
        {}
      std::vector< std::vector<Event> > operator()(TraxelStore&);
	// avobe, nested template class std::vector for type Event, which can be interpreted as a 2D array of Events which change dynamically in size, the generated std:vector class also overloads the operator () with the parameter: reference to class/type TraxelStore `TraxelStore&`
      /**
       * Get state of detection variables after call to operator().
       */
      std::vector< std::map<unsigned int, bool> > detections();

    private: //member definition of globals
      int max_number_objects_;
      ...
    };

In here, the constructor gives default values to the arguments in case of they fail to be specified, later, the global members are initialized by inheritance, later setting them to be private.

## Implementation of class `ConsTracking`













